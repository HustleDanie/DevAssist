"""
Tester Agent - Writes and runs unit tests to validate migration changes.

This agent ensures that the migrated code works correctly by generating
and executing tests in a Docker environment.
"""

import subprocess
import tempfile
import uuid
from pathlib import Path
from typing import Generator

from langchain_core.messages import HumanMessage, SystemMessage
from langchain_openai import ChatOpenAI

from devassist.core.models import (
    MigrationState,
    MigrationStatus,
    CodeChange,
    TestResult,
)
from devassist.core.config import get_settings


class TesterAgent:
    """
    Agent 3: Tester - Writes and runs unit tests.
    
    The Tester agent is responsible for:
    1. Generating unit tests for migrated code
    2. Running tests in Docker environments
    3. Validating that behavior is preserved
    4. Reporting test results and coverage
    
    Supports LLM-free mode with template-based test generation.
    """

    def __init__(self) -> None:
        settings = get_settings()
        self.llm = None
        self.llm_available = False
        
        # Only initialize LLM if API key is set and non-empty
        api_key = settings.openai_api_key
        if api_key and len(api_key) > 10 and not api_key.startswith("your-"):
            try:
                self.llm = ChatOpenAI(
                    model=settings.openai_model,
                    api_key=api_key,
                    temperature=0.3,
                )
                self.llm_available = True
            except Exception as e:
                print(f"[TESTER] LLM initialization failed: {e}")
                self.llm_available = False
        else:
            print("[TESTER] Running in template-only mode (no OpenAI API key configured)")
        
        self.docker_enabled = settings.docker_enabled
        self.docker_image = settings.docker_image
        self.system_prompt = self._build_system_prompt()

    def _build_system_prompt(self) -> str:
        """Build the system prompt for the Tester agent."""
        return """You are an expert test engineer specializing in migration validation.
Your role is to write comprehensive unit tests that verify:
1. The migrated code produces the same output as the original
2. Edge cases are handled correctly
3. Error handling works as expected
4. Type safety is maintained

Test Guidelines:
- Use pytest as the testing framework
- Write clear, descriptive test names
- Include docstrings explaining what each test validates
- Test both happy path and error cases
- Use fixtures for common setup
- Mock external dependencies when needed
- Aim for high code coverage

Test Naming Convention:
- test_<function_name>_<scenario>_<expected_outcome>
- Example: test_parse_config_empty_file_returns_defaults

Return ONLY valid Python test code using pytest."""

    def generate_test(
        self, change: CodeChange, file_content: str
    ) -> str:
        """
        Generate a unit test for a code change.
        
        Uses LLM if available, otherwise falls back to template-based test.
        
        Args:
            change: The code change to test
            file_content: Full content of the migrated file
            
        Returns:
            Generated test code as a string
        """
        if not self.llm_available:
            return self._generate_template_test(change, file_content)
        
        messages = [
            SystemMessage(content=self.system_prompt),
            HumanMessage(content=f"""Generate pytest tests for this code migration.

Original Code:
```python
{change.original_code}
```

New Code:
```python
{change.new_code}
```

File Context:
```python
{file_content}
```

Change Explanation: {change.explanation}

Generate comprehensive tests that verify the new code behaves correctly.""")
        ]

        response = self.llm.invoke(messages)
        return self._clean_test_code(response.content)

    def _generate_template_test(
        self, change: CodeChange, file_content: str
    ) -> str:
        """
        Generate a basic template test when LLM is not available.
        
        Creates a syntax validation test that compiles the module
        and verifies no syntax errors. This test runs standalone
        without pytest.
        """
        file_path = str(change.file_path) if hasattr(change, 'file_path') else str(change.get('file_path', 'unknown'))
        module_name = Path(file_path).stem
        
        # Escape the file content for embedding in the test
        escaped_content = file_content.replace('\\', '\\\\').replace('"""', '\\"\\"\\"')
        
        return f'''#!/usr/bin/env python3
"""
Auto-generated migration validation test for {module_name}.
Generated by DevAssist Tester Agent (AST-only mode).
"""
import ast
import sys

def test_syntax_valid():
    """Test that the migrated code has valid Python 3 syntax."""
    code = """{escaped_content}"""
    
    try:
        ast.parse(code)
        print("[PASS] Syntax validation passed")
        return True
    except SyntaxError as e:
        print(f"[FAIL] Syntax error: {{e}}")
        return False

def test_module_compiles():
    """Test that the module can be compiled without errors."""
    code = """{escaped_content}"""
    
    try:
        compile(code, "<test>", "exec")
        print("[PASS] Compilation validation passed")
        return True
    except Exception as e:
        print(f"[FAIL] Compilation error: {{e}}")
        return False

if __name__ == "__main__":
    passed = True
    passed = test_syntax_valid() and passed
    passed = test_module_compiles() and passed
    
    if passed:
        print("\\nAll tests passed!")
        sys.exit(0)
    else:
        print("\\nSome tests failed!")
        sys.exit(1)
'''

    def _clean_test_code(self, response: str) -> str:
        """Clean the LLM response to extract test code."""
        code = response.strip()
        if code.startswith("```"):
            lines = code.split("\n")
            code = "\n".join(lines[1:-1] if lines[-1] == "```" else lines[1:])
        return code.strip()

    def generate_tests(
        self, changes: list[CodeChange], file_contents: dict[str, str]
    ) -> Generator[tuple[CodeChange, str], None, None]:
        """
        Generate tests for multiple changes using a generator.
        
        Args:
            changes: List of code changes to test
            file_contents: Dictionary mapping file paths to contents
            
        Yields:
            Tuples of (change, test_code)
        """
        for change in changes:
            file_path = str(change.file_path)
            if file_path in file_contents:
                test_code = self.generate_test(change, file_contents[file_path])
                yield change, test_code

    def run_test(
        self, test_code: str, test_name: str, repo_path: Path
    ) -> TestResult:
        """
        Run a single test, optionally in Docker.
        
        Args:
            test_code: The test code to run
            test_name: Name for the test
            repo_path: Path to the repository
            
        Returns:
            TestResult with execution details
        """
        test_id = str(uuid.uuid4())[:8]
        
        # Create temporary test file
        with tempfile.NamedTemporaryFile(
            mode="w", suffix=".py", delete=False, prefix="test_migration_"
        ) as f:
            f.write(test_code)
            test_file = f.name

        try:
            if self.docker_enabled:
                result = self._run_in_docker(test_file, repo_path)
            else:
                result = self._run_locally(test_file, repo_path)

            return TestResult(
                test_id=test_id,
                test_name=test_name,
                passed=result["passed"],
                execution_time=result["execution_time"],
                error_message=result.get("error", ""),
                stdout=result.get("stdout", ""),
                stderr=result.get("stderr", ""),
                coverage=result.get("coverage", 0.0),
            )
        finally:
            # Cleanup temp file
            Path(test_file).unlink(missing_ok=True)

    def _run_in_docker(
        self, test_file: str, repo_path: Path
    ) -> dict:
        """Run test in Docker container."""
        import time
        start_time = time.time()
        
        # Build docker command
        cmd = [
            "docker", "run", "--rm",
            "-v", f"{repo_path}:/app",
            "-v", f"{test_file}:/app/test_migration.py",
            "-w", "/app",
            self.docker_image,
            "python", "-m", "pytest", "/app/test_migration.py", "-v", "--tb=short"
        ]

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            execution_time = time.time() - start_time
            
            return {
                "passed": result.returncode == 0,
                "execution_time": execution_time,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "error": result.stderr if result.returncode != 0 else "",
            }
        except subprocess.TimeoutExpired:
            return {
                "passed": False,
                "execution_time": 300.0,
                "error": "Test timed out after 5 minutes",
                "stdout": "",
                "stderr": "",
            }
        except Exception as e:
            return {
                "passed": False,
                "execution_time": time.time() - start_time,
                "error": str(e),
                "stdout": "",
                "stderr": "",
            }

    def _run_locally(
        self, test_file: str, repo_path: Path
    ) -> dict:
        """Run test locally without Docker."""
        import time
        start_time = time.time()

        # For template tests (AST-only mode), run with Python directly
        # For LLM-generated tests, use pytest
        if self.llm_available:
            cmd = ["python", "-m", "pytest", test_file, "-v", "--tb=short"]
        else:
            # Run test file directly - simpler for template tests
            cmd = ["python", test_file]

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=120,
                cwd=str(repo_path)
            )
            
            execution_time = time.time() - start_time
            
            return {
                "passed": result.returncode == 0,
                "execution_time": execution_time,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "error": result.stderr if result.returncode != 0 else "",
            }
        except subprocess.TimeoutExpired:
            return {
                "passed": False,
                "execution_time": 120.0,
                "error": "Test timed out after 2 minutes",
                "stdout": "",
                "stderr": "",
            }
        except Exception as e:
            return {
                "passed": False,
                "execution_time": time.time() - start_time,
                "error": str(e),
                "stdout": "",
                "stderr": "",
            }

    def run(self, state: MigrationState) -> MigrationState:
        """
        Run the Tester agent on the current migration state.
        
        Args:
            state: Current migration state with applied changes
            
        Returns:
            Updated migration state with test results
        """
        state.status = MigrationStatus.TESTING
        state.current_agent = "tester"
        state.add_message("system", "Tester agent running validation tests...")

        if not state.applied_changes:
            state.add_message("tester", "No changes to test.")
            state.tests_passed = True
            return state

        # Load updated file contents
        file_contents: dict[str, str] = {}
        for change in state.applied_changes:
            file_path = str(change.file_path)
            if file_path not in file_contents:
                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        file_contents[file_path] = f.read()
                except Exception as e:
                    state.add_error(f"Error reading {file_path}: {str(e)}")

        # Generate and run tests
        all_results: list[TestResult] = []
        
        for change, test_code in self.generate_tests(state.applied_changes, file_contents):
            test_name = f"test_{change.change_id}"
            result = self.run_test(
                test_code, 
                test_name, 
                state.repo_path or Path.cwd()
            )
            all_results.append(result)

        state.test_results = all_results
        state.tests_passed = all(r.passed for r in all_results) if all_results else True

        passed_count = sum(1 for r in all_results if r.passed)
        state.add_message(
            "tester",
            f"Test execution complete: {passed_count}/{len(all_results)} tests passed."
        )

        return state
